// Generated by CoffeeScript 1.8.0
(function() {
  var Brick, CheeSynth, Claud, Fixture,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Brick = (function() {
    Brick.prototype.toString = function() {
      return "[object Brick " + this.id + "]";
    };

    function Brick(opt) {
      this.id = opt.id;
    }

    Brick.prototype.render = function() {
      return ['L--M--R', '|     |', "C " + this.id + " c", '|     |', 'l==m==r'];
    };

    return Brick;

  })();

  CheeSynth = (function() {
    CheeSynth.prototype.toString = function() {
      return '[object CheeSynth]';
    };

    function CheeSynth(opt) {
      if (opt == null) {
        opt = {};
      }
      this.el = opt.el;
      this.width = opt.width;
      this.height = opt.height;
      this.fixtures = [];
    }

    CheeSynth.prototype.add = function(x, y, brick) {
      var fixture;
      this.fixtures.push(fixture = new Fixture({
        id: 'f' + this.fixtures.length,
        x: x,
        y: y,
        brick: brick
      }));
      return fixture;
    };

    CheeSynth.prototype.composit = function() {
      var char, fixture, i, pin, x, y, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _ref2;
      this.cb = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 1, _ref = this.width; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
          _results.push((function() {
            var _j, _ref1, _results1;
            _results1 = [];
            for (i = _j = 1, _ref1 = this.height; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 1 <= _ref1 ? ++_j : --_j) {
              _results1.push({});
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
      this.cb.helper = {
        top: {},
        right: [],
        bottom: [],
        left: {}
      };
      _ref = this.fixtures;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        fixture = _ref[_i];
        fixture.composit(this.cb);
      }
      _ref1 = this.cb.helper.bottom;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        pin = _ref1[_j];
        y = pin.y;
        while (this.height > y) {
          char = this.cb.helper.top[pin.x + ',' + y];
          if (char) {
            if (char.p) {
              y = pin.y + 1;
              while (char.y > y) {
                this.cb[pin.x][y] = {
                  c: '|'
                };
                y++;
              }
            }
            break;
          }
          y++;
        }
      }
      _ref2 = this.cb.helper.right;
      for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
        pin = _ref2[_k];
        x = pin.x;
        while (this.width > x) {
          char = this.cb.helper.left[x + ',' + pin.y];
          if (char) {
            if (char.p) {
              x = pin.x + 1;
              while (char.x > x) {
                this.cb[x][pin.y].c = '|' === this.cb[x][pin.y].c ? '+' : '—';
                x++;
              }
            }
            break;
          }
          x++;
        }
      }
    };

    CheeSynth.prototype.render = function() {
      var c, out, x, y, _i, _j, _ref, _ref1;
      this.composit();
      out = '';
      for (y = _i = 0, _ref = this.height - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        for (x = _j = 0, _ref1 = this.width - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          c = this.cb[x][y].c;
          out += c ? c : '·';
        }
        out += '\n';
      }
      return this.el.innerHTML = out;
    };

    return CheeSynth;

  })();

  Claud = (function() {
    Claud.prototype.toString = function() {
      return '[object Claud]';
    };

    function Claud(opt) {
      if (opt == null) {
        opt = {};
      }
      this.keydown = __bind(this.keydown, this);
      this.log = new Filog({
        selector: opt.selectors.out,
        console: false
      }).log;
      this["in"] = document.querySelector(opt.selectors["in"]);
      this["in"].setAttribute('contenteditable', 'true');
      this["in"].addEventListener('keydown', this.keydown);
      this.commands = [];
      this.pointer = 0;
    }

    Claud.prototype.add = function(line) {
      this.pointer = (this.commands.push(this.log(line))) - 1;
      return this;
    };

    Claud.prototype.run = function() {
      var e;
      try {
        return eval(this.commands[this.commands.length - 1]);
      } catch (_error) {
        e = _error;
        return this.log(e);
      }
    };

    Claud.prototype.keydown = function(evt) {
      switch (evt.keyCode) {
        case 13:
          this.pointer = (this.commands.push(this.log(this["in"].textContent))) - 1;
          this["in"].innerHTML = '';
          this.run();
          return evt.preventDefault();
        case 38:
          this.pointer = Math.max(0, this.pointer - 1);
          this["in"].innerHTML = this.commands[this.pointer];
          return evt.preventDefault();
        case 40:
          this.pointer = Math.min(this.commands.length - 1, this.pointer + 1);
          this["in"].innerHTML = this.commands[this.pointer];
          return evt.preventDefault();
      }
    };

    return Claud;

  })();

  window.Claud = Claud;

  Fixture = (function() {
    Fixture.prototype.toString = function() {
      return "[object Fixture " + this.id + "]";
    };

    function Fixture(opt) {
      this.id = opt.id;
      this.x = opt.x;
      this.y = opt.y;
      this.brick = opt.brick;
    }

    Fixture.prototype.composit = function(cb) {
      var absX, absY, char, col, isBottom, isLeft, isRight, isTop, line, lines, meta, x, y, _i, _j, _len, _len1, _ref;
      if (0 > this.x || 0 > this.y) {
        throw new Error("" + this + " has -ve position");
      }
      if (!cb[this.x]) {
        throw new Error("" + this + " is beyond x edge");
      }
      if (!cb[this.x][this.y]) {
        throw new Error("" + this + " is beyond y edge");
      }
      lines = this.brick.render();
      for (y = _i = 0, _len = lines.length; _i < _len; y = ++_i) {
        line = lines[y];
        absY = this.y + y;
        if (!cb[this.x][absY]) {
          throw new Error("" + this + " is too tall");
        }
        _ref = line.split('');
        for (x = _j = 0, _len1 = _ref.length; _j < _len1; x = ++_j) {
          char = _ref[x];
          absX = this.x + x;
          col = cb[absX];
          if (!col) {
            throw new Error("" + this + " is too wide");
          }
          if (col[absY].f) {
            throw new Error("" + this + " overlaps " + col[absY].f);
          }
          meta = col[absY] = {
            f: this,
            c: char,
            x: absX,
            y: absY
          };
          isTop = 0 === y;
          isLeft = 0 === x;
          if (!isTop) {
            isBottom = lines.length - 1 === y;
          }
          if (!isLeft) {
            isRight = line.length - 1 === x;
          }
          if (isTop || isRight || isBottom || isLeft) {
            meta.p = /[a-zA-Z]/.test(char);
            if (isTop) {
              cb.helper.top[absX + ',' + absY] = meta;
            }
            if (isLeft) {
              cb.helper.left[absX + ',' + absY] = meta;
            }
            if (meta.p) {
              if (isRight) {
                cb.helper.right.push(meta);
              }
              if (isBottom) {
                cb.helper.bottom.push(meta);
              }
            }
          }
        }
      }
    };

    return Fixture;

  })();

  CheeSynth.Brick = Brick;

  window.CheeSynth = CheeSynth;

}).call(this);
